#!/usr/bin/env perl

# Parse the blat output files generated by the script map-array-probes_run-blat.pl

# MODULES
use strict;
use Getopt::Long;


# GET ARGUMENTS
my $sHelp        = 0;
my $sInputdir       = '';
my $nMismatchCut = 0;
my $nCutoff      = 1;
my $sOutput      = '';
GetOptions("help!"        => \$sHelp,
           "input:s"      => \$sInputdir,
           "cutoff:i"     => \$nCutoff,
           "mismatch:i"   => \$nMismatchCut,
	   "output:s"     => \$sOutput);



# PRINT HELP
$sHelp = 1 unless($sInputdir and $sOutput);
if ($sHelp) {
    die <<HELP

    map-array-probes_blat2gff.pl -i <input> -o <output gff file> [-c <cutoff> -m <mismatches>]

    arguments:
    -i Input directory
        Directory with concatenated BLAT mapping files (without header)
    -m Mismatch
        The maximum number of mismatches allowed
        Default: 0
    -c Cutoff
        Maximum number of copies in the genome allowed, put 0 for no maximum
        Default: 1
    -o Output file prefix
        Name for the output file
    -h Help

HELP
}

##########
# Start ##
##########


# Process all files in the output folder
my %hLUT;
opendir DIR, $sInputdir or die "Can't open blat output dir: $!\n";
while (defined(my $sFile = readdir(DIR))) {
   next unless ($sFile =~ /\.psl/);
   open INPUT, "$sInputdir/$sFile" or die "Can't open BLAT output file '$sFile': $!\n";
   while (<INPUT>){
      next if (/^\s*$/);
      s/[\n\r]//g;
      s/ //g;
      my (@asTmp) = split /\t/;
      my ($nMatch, $nGaps, $sStrand, $sQname, $nQsize, $sTname, $nTstart, $nTend) = @asTmp[0,6,8,9,10,13,15,16];
      my $nCompareQuery = $nMatch + $nMismatchCut;
      if ( ($nCompareQuery >= $nQsize) and ($nGaps==0) ){
         my $nScore = 1000;
         push @{$hLUT{$sQname}}, [$sTname, 'array', 'oligo', $nTstart, $nTend, $nScore, $sStrand, '.', $sQname];
      }
   }
}


# Create hash of all mapped oligo features per chromosome
my @asDropped;
my $nDropCount = 0;
my %hOutput;
my %hSortOrder;
foreach my $sFeature (keys(%hLUT)){
    my @asTmp     = @{$hLUT{$sFeature}};
    if (scalar(@asTmp)<=$nCutoff){
	for (my $i=0 ; $i<@asTmp ; $i++ ){
	    my @asLine = @{$asTmp[$i]};
	    $asLine[$#asLine] = join(':', $asLine[$#asLine], $i) if (scalar(@asTmp)>1);
	    $asLine[5]        = int(1000/scalar(@asTmp));
	    my $sChr          = shift @asLine;
	    push @{$hOutput{$sChr}}, [@asLine];
	    push @{$hSortOrder{$sChr}}, $asLine[2];
	}
    }
    else{
	push @asDropped, $sFeature;
    }
}


# Sort the output by chromosome and position. This will speed up loading in IGB
my @asChromosomeIDs = qw(chr1 chr2 chr3 chr4 chr5 chr6 chr7 chr8 chr9 chr10 chr11 chr12 chr13 chr14 chr15
                         chr16 chr17 chr18 chr19 chr20 chr21 chr22 chr23 chr24 chr25 chr26 chr27 chr28 chr29
                         chr30 chr31 chr32 chrX chrY chrx chry chrM chrm chr1_random chr2_random chr3_random 
                         chr4_random chr5_random chr6_random chr7_random chr8_random chr9_random chr10_random
                         chr11_random chr12_random chr13_random chr14_random chr15_random chr16_random 
                         chr17_random chr18_random chr19_random chr20_random chr21_random chr22_random 
                         chr23_random chr24_random chr25_random chr26_random chr27_random chr28_random 
                         chr29_random chr30_random chr31_random chr32_random chrX_random chrY_random chrx_random 
                         chry_random chrM_random chrm_random);
open OUT, ">$sOutput.gff" or die "Can't open $sOutput.gff: $!\n";
print OUT "track name=\"Array features\" useScore=1 color=0,0,0 visibility=2 \n";
my $nChromosomeCheck = 0;
foreach my $sChromosome (@asChromosomeIDs){
   if (exists($hOutput{$sChromosome})){
      my @asOutput    = @{$hOutput{$sChromosome}};
      my @asPositions = @{$hSortOrder{$sChromosome}};
      my @anIndex     = 0 .. (scalar(@asPositions)-1);
      my @anSortIndex = sort{$asPositions[$a] <=> $asPositions[$b]} @anIndex;
      @asOutput       = @asOutput[@anSortIndex];
      foreach my $rLine (@asOutput){ print OUT join("\t", $sChromosome, @$rLine), "\n"; }
      $nChromosomeCheck++;
   }
}
close OUT;
unless ($nChromosomeCheck == scalar(keys(%hOutput))){
   print STDERR "WARNING: Not all chromosomes were written to output file, please include missing chromosome names in sorting list!!\n";
}


# Dump the list of features occurring multiple times
open DROPPED, ">$sOutput-dropped.txt" or die "Can't open $sOutput-dropped.txt: $!\n";
foreach my $sFeature (@asDropped) {print DROPPED $sFeature, "\n"}
close DROPPED;
